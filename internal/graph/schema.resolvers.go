package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"Service/internal/auth"
	"Service/internal/graph/model"
	"context"
	"errors"
	"fmt"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResponse, error) {
	data, user, err := r.authUC.SignUp(ctx, auth.SignUpParams{
		Email:     input.Email,
		FirstName: input.FirstName,
		Password:  input.Password,
	})
	if err != nil {
		return nil, err
	}
	response := &model.AuthResponse{
		AuthToken: &model.AuthToken{AccessToken: data.Access, RefreshToken: data.Refresh},
		User:      &model.User{UUID: user.UUID, Email: user.Email, FirstName: user.FirstName},
	}
	return response, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	data, user, err := r.authUC.SignIn(ctx, auth.SignInParams{Email: input.Email, Password: input.Password})
	if err != nil {
		return nil, err
	}
	response := &model.AuthResponse{
		AuthToken: &model.AuthToken{AccessToken: data.Access, RefreshToken: data.Refresh},
		User:      &model.User{UUID: user.UUID, Email: user.Email, FirstName: user.FirstName},
	}
	return response, nil
}

// Refresh is the resolver for the refresh field.
func (r *mutationResolver) Refresh(ctx context.Context, input model.RefreshInput) (*model.AuthResponse, error) {
	uuid, ok := ctx.Value("uuid").(string)
	if !ok {
		return nil, errors.New("unauthorized")
	}
	data, user, err := r.authUC.Refresh(ctx, auth.RefreshParams{UserUUID: auth.UserUUID{UUID: uuid}, Refresh: input.Refresh})
	if err != nil {
		return nil, err
	}
	response := &model.AuthResponse{
		AuthToken: &model.AuthToken{AccessToken: data.Access, RefreshToken: input.Refresh},
		User:      &model.User{UUID: user.UUID, Email: user.Email, FirstName: user.FirstName},
	}
	return response, nil
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, input model.NewPost) (*model.Post, error) {
	panic(fmt.Errorf("not implemented: CreatePost - createPost"))
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input *model.NewComment) (*model.Comment, error) {
	panic(fmt.Errorf("not implemented: CreateComment - createComment"))
}

// Comments is the resolver for the comments field.
func (r *postResolver) Comments(ctx context.Context, obj *model.Post) ([]*model.Comment, error) {
	panic(fmt.Errorf("not implemented: Comments - comments"))
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	return []*model.Post{}, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, input model.GetCommentsInput) ([]*model.Comment, error) {
	panic(fmt.Errorf("not implemented: Comments - comments"))
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
